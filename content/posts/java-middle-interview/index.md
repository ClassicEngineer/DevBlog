---
title: "Java Middle Собеседование"
date: 2023-07-19T13:41:12+03:00
image: "star_coder.jpg"
draft: false
tags:
  - tech
---

В этом посте хотел бы собрать вопросы, которые бы подошли для собеседования.
Список неполный, дополняется редко. Ответы будут браться с других сайтов.
Делается только под себя (Как и все в этом месте).


# Базы данных


## Аномалии параллельных транзакций.


1. __Потерянное обновление (lost update)__

Когда разные транзакции одновременно изменяют одни и те же данные, то после фиксации изменений может оказаться, что одна транзакция перезаписала данные, обновленные и зафиксированные другой транзакцией.

2. __«Грязное» чтение (dirty read)__

Транзакция читает данные, измененные параллельной транзакцией, которая еще не завершилась. 

3. __Неповторяющееся чтение (non-repeatable read)__

При повторном чтении тех же самых данных в рамках одной транзакции оказывается, что другая транзакция успела изменить и зафиксировать эти данные.

4. __Фантомное чтение (phantom read).__

Транзакция повторно выбирает множество строк в соответствии с одним и тем же критерием. В интервале времени между выполнением этих выборок другая транзакция добавляет новые строки и успешно фиксирует изменения.
В результате при выполнении повторной выборки в первой транзакции может быть получено другое множество строк.

5. __Аномалия сериализации (serialization anomaly)__

Результат успешной фиксации группы транзакций, выполняющихся параллельно, не совпадает с результатом ни одного из возможных вариантов упорядочения этих транзакций,
если бы они выполнялись последовательно.


## Уровни изоляции базы данных

1. __Read Uncommitted__

Это самый низкий уровень изоляции. Согласно стандарту SQL на этом уровне допускается чтение «грязных» (незафиксированных) данных.


2. __Read Committed__

Не допускается чтение «грязных» (незафиксированных) данных.
Транзакция может видеть только те незафиксированные изменения данных, которые произведены в ходе выполнения ее самой.


3. __Repeatable Read__

Не допускается чтение «грязных» (незафиксированных) данных и неповторяющееся чтение. В PostgreSQL на этом уровне не допускается также фантомное чтение.


4. __Serializable__

Не допускается ни один из феноменов, перечисленных выше, в том числе и аномалии сериализации.



# Java

## Иерархия классов коллекций

![](collection-structure.png)

## Все стандартные реализации коллекций и как они устроены внутри

## Как работает ClassLoader

![](class-loader.png)


## Какие есть примитивы синхронизации

### Мониторы
lock, synchronized

### Synchronizers
Semaphor, CountDownLatch (замок с обратным отсчетом), CyclicBarrier, Exchanger<V>, Phaser

### Concurrent Collections

Как коллекции устроены внутри и чем synchronized версии коллекций отличаются от concurrent версий

### Executors

### Atomics

Как Atomics устроены внутри

## happens-before

«Выполняется прежде» (англ. happens before) — отношение строгого частичного порядка (антирефлексивное, антисимметричное, транзитивное), введённое между атомарными командами.
Оно значит, что вторая команда будет «в курсе» изменений, проведённых первой. 

## WeakReference


- SoftReference — если GC видит что объект доступен только через цепочку soft-ссылок, то он удалит его из памяти.

- WeakReference — если GC видит что объект доступен только через цепочку weak-ссылок, то он удалит его из памяти.

- PhantomReference — если GC видит что объект доступен только через цепочку phantom-ссылок, то он его удалит из памяти. После нескольких запусков GC.


Главная плюшка SoftReference в том что JVM сама следит за тем нужно удалять из памяти объект или нет. И если осталось мало памяти, то объект будет удален.

Ну конечно WeakHashMap. Это реализация Map<K,V> которая хранит ключ, используя weak-ссылку. И когда GC удаляет ключ с памяти, то удаляется вся запись с Map

## Как устроена JVM

![](JVM-Architecture.png)

## Stack VS Heap

![](stack_vs_heap.png)

## Как работает Clone


## Какие бывают сборщики мусора и чем они различаются?

G1, Parallel, ConcurrentMarkSweep


## Куда подевался PermGen?

![](metaspace.webp)

## Java Memory Model


## Как работают Stream внутри


## Что такое / Как работает JIT-компиляция

технология увеличения производительности программных систем,
использующих байт-код, путём компиляции байт-кода в машинный код или в другой формат непосредственно во время работы программы

# Spring

## Что такое BeanFactoryPostProcessor и когда он используется?

BeanFactoryPostProcessor работает над описаниями бинов или конфигурационными метаданными перед тем, как бин будет создан.
Spring поставляет несколько полезных реализаций BeanFactoryPostProcessor, например, читающий property-файлы и получающий из них свойства бинов.

## Что такое BeanDefenitions

## Виды scope

singleton - Возвращает один и тот же экземпляр бина на каждый запрос контейнера Spring IoC (по умолчанию).

prototype - Создает и возвращает новый экземпляр бина на каждый запрос.

request - Создает и возвращает экземпляр бина на каждый HTTP запрос*.

session - Создает и возвращает экземпляр бина для каждой HTTP сессии*.

global-session - Создает и возвращает экземпляр бина для глобальной HTTP сессии*. 

## Жизненный цикл бина

## Жизненный цикл контекста

## Преимущества IoC
IoC - inversion of control, один из видов(реализаций) - DI, Dependency Injection
При применении DI, ваш код становится чище, проще, его становится легче понять и тестировать.
Согласно паттерну DI, создание объектов для зависимостей переходит на фабрику или отдается третьей стороне.
Это означает, что мы можем сосредоточиться на использовании этих объектов вместо их создания.


## Как написать свой Spring Boot Starter ?

См. [](https://doka.blog/spring-boot-starter)

## Пример Prototype inside singleton.


Как работает инъекция прототипа в синглтон?

Допустим ситуацию, когда в singleton-компонент внедряется зависимость со скоупом prototype – когда будет создан её объект?

Если просто добавить к определению бина аннотацию @Scope(SCOPE_PROTOTYPE), и использовать этот бин в синглтоне через аннотацию @Autowired – будет создан только один объект.
Потому что синглтон создается только однажды, и обращение к прототипу случится тоже однажды при его создании (при внедрении зависимости).

Примитивный способ получать новый объект при каждом обращении – отказаться от @Autowired, и доставать его из контекста вручную.
Для этого нужно вызывать context.getBean(MyPrototype.class).

Воспользоваться автоматическим внедрением зависимостей можно через внедрение метода . Автовайрится не сам объект, а производящий его метод.

Более красивый декларативный способ – правильно настроить определение бина.
В аннотации @Scope кроме самого scopeName доступен второй параметр – proxyMode. По умолчанию его значение NO – прокси не создается.
Но если указать INTERFACES или TARGET_CLASS, то под @Autowired будет внедряться не сам объект, а сгенерированный фреймворком прокси.
И когда проксируемый бин имеет скоуп prototype, то объект внутри прокси будет пересоздаваться при каждом обращении.

## Hibernate и Lazy

Сказать про транзакцию))

## Rollback транзакции

По умолчанию Spring откатывает транзакции только в случае непроверяемого исключения.
Проверяемые же считаются «восстанавливаемыми» из-за чего Spring вместо rollback делает commit




## Пример Transaction call inside bean \ Scheduled.

Транзакция не будет создана из-за проксирования, так как класс вызовет сам себя, а должен вызваться извне прокси


## Какие настройки есть у аннотации Transactional



# Microservices

## Паттерны микросервисов

![](microservices_patterns.png)

[microservices.io](https://microservices.io/patterns/index.html)

## Как устроена Kafka

## Зачем нужны consumer's group id.


# Clean Code

## Design Patterns

## SOLID



[Бонус](https://www.youtube.com/watch?v=QI-bXKC2mvU)